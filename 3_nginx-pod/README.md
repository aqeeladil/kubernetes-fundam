# Creating a Simple NGINX Pod using KOPS & Aws-EC2-Instance

Using kOps to create a Kubernetes cluster on EC2 is a powerful way to deploy Kubernetes in a customizable, self-managed environment without needing to rely on AWS EKS. 

This approach is ideal for those who want fine-grained control over their Kubernetes infrastructure. Below is a step-by-step guide to setting up and deploying a Kubernetes cluster on AWS EC2 instances using kOps.

#### Overview of the Setup
  1. Create an S3 Bucket for kOps to store cluster state and configurations.
  2. Set up a domain name in Route 53 or an existing DNS provider to manage Kubernetes DNS      
     requirements.
  3. Install kOps and create a Kubernetes cluster configuration.
  4. Deploy the cluster to EC2 instances.
  5. Deploy the NGINX Pod and expose it for external access.

## Step 1: Set Up an S3 Bucket for State Storage

kOps uses an S3 bucket as a "state store" to save configuration, secrets, and state files for the cluster.

1. **Create the S3 Bucket:**
- Go to the S3 console in AWS or use the AWS CLI to create the bucket. The bucket name should be globally unique.
```bash
aws s3api create-bucket --bucket your-kops-state-store --region us-west-2
```
2. **Enable Versioning on the S3 bucket (recommended by kOps to preserve changes):**
```bash
aws s3api put-bucket-versioning --bucket your-kops-state-store --versioning-configuration Status=Enabled
```
3. **Set an Environment Variable to reference the S3 bucket for kOps commands:**
```bash
export KOPS_STATE_STORE=s3://your-kops-state-store
```

## Step 2: Set Up a DNS Domain for Kubernetes:

kOps requires DNS to manage Kubernetes networking, so a DNS zone must be configured.

1. **Register a Domain:** If you don’t have one, register a domain using Route 53 or any DNS provider.
2. **Create a Hosted Zone in Route 53:** This will allow kOps to create DNS entries as part of the cluster setup.
```bash
aws route53 create-hosted-zone --name k8s.example.com --caller-reference 1
```
Note the hosted zone ID returned by the command; you’ll need it for kOps commands.

## Step 3: Install kOps and kubectl

1. **Install kOps:**
```bash
curl -LO https://github.com/kubernetes/kops/releases/download/v1.26.0/kops-linux-amd64
chmod +x kops-linux-amd64
sudo mv kops-linux-amd64 /usr/local/bin/kops
```
2. **Install kubectl:**
- Install kubectl to interact with your Kubernetes cluster once it’s up and running.
```bash
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl
sudo mv kubectl /usr/local/bin/kubectl
```

## Step 4: Create the Kubernetes Cluster

1. **Create the Cluster Configuration:** Use kOps to define your cluster's initial configuration. Replace k8s.example.com with your actual DNS name.
```bash
kops create cluster --name=k8s.example.com --state=$KOPS_STATE_STORE --zones=us-west-2a --node-count=2 --node-size=t3.medium --dns-zone=k8s.example.com
```
This command creates the cluster configuration but does not actually start the cluster yet.
2. **Review and Update Configuration (optional):** 
You can view or edit the configuration generated by kOps to adjust any parameters, such as node sizes or availability zones.
```bash
kops edit cluster k8s.example.com --state=$KOPS_STATE_STORE
```
3. **Deploy the Cluster:** 
Once satisfied with the configuration, apply it:
```bash
kops update cluster k8s.example.com --yes --state=$KOPS_STATE_STORE
```
kOps will create and configure the EC2 instances, networking, IAM roles, and more, needed to set up the Kubernetes cluster. This step may take a few minutes.
4. **Validate the Cluster:** 
Check that the cluster is up and running:
```bash
kops validate cluster --state=$KOPS_STATE_STORE
```
You should see output confirming that all nodes are up and Kubernetes is ready.

## Step 5: Deploy the NGINX Pod
Now that your cluster is running, you can use kubectl to deploy applications.
1. **Save the NGINX Pod YAML file** (```nginx-pod.yaml```):
```bash
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
      ports:
        - containerPort: 80
```
2. **Apply the Configuration:**
```bash
kubectl apply -f nginx-pod.yaml
```
3. **Verify the Pod:**
```bash
kubectl get pods
```
You should see the nginx-pod with a status of Running.

## Step 6: Expose the NGINX Pod with a LoadBalancer

To access the NGINX server from outside, expose the Pod as a service with type LoadBalancer:
```bash
kubectl expose pod nginx-pod --type=LoadBalancer --name=nginx-service --port=80 --target-port=80
```
AWS will automatically create an ELB (Elastic Load Balancer) to route traffic to the NGINX Pod.

## Step 7: Access the NGINX Web Server

1. Run the following command to get the external IP or DNS of the load balancer:
```bash
kubectl get svc nginx-service
```
2. Visit the URL listed under EXTERNAL-IP in your browser (e.g., http://<EXTERNAL-IP>). You should see the default NGINX welcome page, confirming that your Pod is accessible.

## Step 8: Clean Up
When you’re done, you can delete the cluster and all associated resources with:
```bash
kops delete cluster --name=k8s.example.com --state=$KOPS_STATE_STORE --yes
```
This will tear down the cluster, release the EC2 instances, and clean up any associated resources.